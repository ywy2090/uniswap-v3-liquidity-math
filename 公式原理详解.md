# Uniswap v3 流动性数学公式原理详解

## 目录

1. [核心概念](#核心概念)
2. [基础公式推导](#基础公式推导)
3. [流动性计算](#流动性计算)
4. [代币数量计算](#代币数量计算)
5. [价格边界计算](#价格边界计算)
6. [实际应用案例](#实际应用案例)

---

## 核心概念

### 1. 什么是流动性 (Liquidity, L)？

在Uniswap v3中，**流动性L**是一个抽象的数学概念，表示在特定价格范围内可用于交易的资产数量。它不是简单的代币数量相加，而是一个计算出来的值，用于描述价格变化时资产的转换能力。

**关键特点：**

- L是一个常数值（在没有添加/移除流动性时）
- L越大，价格滑点越小
- L与价格范围和代币数量相关

### 2. 为什么使用价格平方根？

Uniswap v3使用价格的平方根（√P）而不是价格本身，主要原因：

1. **数学简化**：使用√P可以将复杂的乘法转换为简单的加减法
2. **精度提升**：避免大数值运算，提高计算精度
3. **Gas优化**：智能合约中的计算更高效

**表示方法：**

- P = token1/token0 的价格比率
- √P = P的平方根
- 当前价格：sp = √P
- 价格下限：sa = √P_a
- 价格上限：sb = √P_b

### 3. Tick机制

Tick是Uniswap v3中离散化的价格点：

- **Tick基数**：1.0001
- **价格公式**：P = 1.0001^tick
- **Tick间距**：由池子的费率等级决定（1, 10, 60, 200）

**为什么需要Tick？**

- 离散化价格，减少状态存储
- 便于追踪流动性分布
- 优化Gas消耗

---

## 基础公式推导

### 1. Uniswap v2的恒定乘积公式

首先回顾Uniswap v2的核心公式：

```
x * y = k (常数)
```

其中：

- x = token0的数量
- y = token1的数量
- k = 恒定乘积

**价格关系：**

```
P = y/x  （token1相对于token0的价格）
```

### 2. Uniswap v3的集中流动性

Uniswap v3引入了**集中流动性**概念，允许流动性提供者在特定价格范围[P_a, P_b]内提供流动性。

**关键创新：**

- 流动性只在指定价格范围内有效
- 相同的资本在更窄的范围内可以提供更高的流动性
- 资本效率大幅提升

### 3. 流动性L的定义

根据Uniswap v3白皮书，流动性L定义为：

```
L = √(x * y * P)  （在特定价格P下）
```

但这个定义需要根据价格位置进行调整。

---

## 流动性计算

### 公式1：仅使用token0计算流动性（价格低于范围时）

```python
L = x * √P * √P_b / (√P_b - √P)
```

**推导过程：**

当价格低于范围下限（P < P_a）时，所有流动性都是token0形式。

从Uniswap v3的核心公式开始：

```
Δ(1/√P) * L = Δx
```

在价格范围[P, P_b]内：

```
(1/√P - 1/√P_b) * L = x
```

整理得：

```
L = x / (1/√P - 1/√P_b)
  = x * √P * √P_b / (√P_b - √P)
```

**物理意义：**

- 当前价格越接近P_b，需要的token0越少
- 价格范围越窄，相同的x可以提供更高的L

### 公式2：仅使用token1计算流动性（价格高于范围时）

```python
L = y / (√P_b - √P_a)
```

**推导过程：**

当价格高于范围上限（P > P_b）时，所有流动性都是token1形式。

从核心公式：

```
Δ√P * L = Δy
```

在价格范围[P_a, P_b]内：

```
(√P_b - √P_a) * L = y
```

整理得：

```
L = y / (√P_b - √P_a)
```

**物理意义：**

- 流动性与价格范围的宽度成反比
- 价格范围越窄，相同的y可以提供更高的L

### 公式3：使用两种代币计算流动性（价格在范围内）

```python
if P ≤ P_a:
    L = get_liquidity_0(x, √P_a, √P_b)
elif P_a < P < P_b:
    L0 = get_liquidity_0(x, √P, √P_b)
    L1 = get_liquidity_1(y, √P_a, √P)
    L = min(L0, L1)
else:
    L = get_liquidity_1(y, √P_a, √P_b)
```

**逻辑说明：**

1. **P ≤ P_a**：价格低于范围，仅使用token0
2. **P_a < P < P_b**：价格在范围内，两种代币都存在
   - 分别计算两种代币能提供的流动性
   - 取较小值，确保两种代币都足够
3. **P ≥ P_b**：价格高于范围，仅使用token1

**为什么取min？**

- 流动性受到较少代币的限制
- 保证在整个价格范围内都有足够的资产支持

---

## 代币数量计算

### 公式4：根据流动性计算token0数量

```python
x = L * (√P_b - √P) / (√P * √P_b)
```

**推导过程：**

从核心公式：

```
Δ(1/√P) * L = Δx
```

当前价格P到上限P_b的token0变化：

```
x = L * (1/√P - 1/√P_b)
  = L * (√P_b - √P) / (√P * √P_b)
```

**边界情况处理：**

```python
√P = max(min(√P, √P_b), √P_a)
```

- 如果P < P_a，使用P_a（所有都是token1）
- 如果P > P_b，使用P_b（x = 0）

**物理意义：**

- 价格越高，token0越少
- 当P = P_b时，x = 0
- 当P = P_a时，x最大

### 公式5：根据流动性计算token1数量

```python
y = L * (√P - √P_a)
```

**推导过程：**

从核心公式：

```
Δ√P * L = Δy
```

从下限P_a到当前价格P的token1变化：

```
y = L * (√P - √P_a)
```

**边界情况处理：**
同样需要确保√P在范围内。

**物理意义：**

- 价格越高，token1越多
- 当P = P_a时，y = 0
- 当P = P_b时，y最大

---

## 价格边界计算

### 公式6：计算价格下限P_a（方法1，使用流动性）

```python
P_a = (√P - y/L)²
```

**推导过程：**

从公式：

```
L = y / (√P - √P_a)
```

整理得：

```
√P - √P_a = y / L
√P_a = √P - y / L
P_a = (√P - y/L)²
```

**应用场景：**

- 已知流动性L、当前价格P、token1数量y
- 求价格下限P_a

### 公式7：计算价格下限P_a（方法2，不使用流动性）

```python
√P_a = y/(√P_b * x) + √P - y/(√P * x)
P_a = (√P_a)²
```

**推导过程：**

结合两个核心公式：

```
x * √P * √P_b / (√P_b - √P) = y / (√P - √P_a)
```

通过代数运算消去L，求解√P_a：

```
√P_a = y/(√P_b * x) + √P - y/(√P * x)
```

简化：

```
√P_a = y/(√P_b * x) + √P - y/(√P * x)
```

**应用场景：**

- 已知两种代币数量x、y和价格上限P_b
- 不需要预先计算流动性
- 更适合实际应用场景

### 公式8：计算价格上限P_b（方法1，使用流动性）

```python
P_b = (L * √P / (L - √P * x))²
```

**推导过程：**

从公式：

```
L = x * √P * √P_b / (√P_b - √P)
```

整理得：

```
L * (√P_b - √P) = x * √P * √P_b
L * √P_b - L * √P = x * √P * √P_b
L * √P_b - x * √P * √P_b = L * √P
√P_b * (L - x * √P) = L * √P
√P_b = L * √P / (L - x * √P)
P_b = (L * √P / (L - √P * x))²
```

### 公式9：计算价格上限P_b（方法2，不使用流动性）

```python
√P_b = (√P * y) / ((√P_a * √P - P) * x + y)
P_b = (√P_b)²
```

**推导过程：**

类似地，结合两个核心公式并消去L，求解√P_b。

---

## 价格比率计算

### 公式10：计算价格比率c和d

```python
c = √P_b / √P  （上限比率）
d = √P_a / √P  （下限比率）
```

**用途：**

- 表示价格范围相对于当前价格的位置
- c > 1：价格上限高于当前价格
- d < 1：价格下限低于当前价格

### 公式11：根据代币数量计算c

```python
c = y / ((d - 1) * P * x + y)
```

**推导：**

从流动性公式出发，通过代数变换得到c与x、y、P、d的关系。

### 公式12：根据代币数量计算d

```python
d = 1 + y * (1 - c) / (c * P * x)
```

**推导：**

类似地，通过代数变换得到d的表达式。

---

## 价格变化时的资产变化

### 增量公式（Delta计算）

当价格从P₀变化到P₁时，代币数量的变化：

```python
Δx = L * (1/√P₁ - 1/√P₀)
Δy = L * (√P₁ - √P₀)
```

**推导：**

这是从核心微分方程直接积分得到的：

```
dx = L * d(1/√P)
dy = L * d(√P)
```

**应用：**

- 计算价格变化后的资产余额
- 估算交易对价格的影响
- 计算无常损失

**示例（Example 3中的应用）：**

假设价格从2000变为2500：

```python
√P₀ = √2000 ≈ 44.72
√P₁ = √2500 = 50

Δx = L * (1/50 - 1/44.72) = L * (-0.00236)
Δy = L * (50 - 44.72) = L * 5.28
```

这意味着：

- token0（ETH）减少（被卖出）
- token1（USDC）增加（被买入）

---

## 实际应用案例

### 案例1：计算需要的配对资产

**问题：** 我有2个ETH，当前价格1 ETH = 2000 USDC，价格范围[1500, 2500]，需要多少USDC？

**解决步骤：**

1. 计算价格平方根：

   ```
   √P = √2000 ≈ 44.72
   √P_a = √1500 ≈ 38.73
   √P_b = √2500 = 50
   ```

2. 用token0计算流动性：

   ```
   L = x * √P * √P_b / (√P_b - √P)
     = 2 * 44.72 * 50 / (50 - 44.72)
     ≈ 847.8
   ```

3. 计算需要的token1：

   ```
   y = L * (√P - √P_a)
     = 847.8 * (44.72 - 38.73)
     ≈ 5076.1 USDC
   ```

### 案例2：计算价格范围

**问题：** 我有2 ETH和4000 USDC，价格上限3000 USDC，价格下限是多少？

**解决步骤：**

1. 已知：

   ```
   x = 2, y = 4000, P = 2000, P_b = 3000
   ```

2. 计算平方根：

   ```
   √P = 44.72
   √P_b = 54.77
   ```

3. 使用方法2计算P_a：

   ```
   √P_a = y/(√P_b * x) + √P - y/(√P * x)
        = 4000/(54.77 * 2) + 44.72 - 4000/(44.72 * 2)
        ≈ 36.51
   
   P_a = 36.51² ≈ 1333.33
   ```

### 案例3：价格变化后的资产

**问题：** 使用案例2的头寸，当价格变为2500时，资产余额是多少？

**解决步骤：**

1. 计算初始流动性：

   ```
   L = get_liquidity(x=2, y=4000, √P=44.72, √P_a=36.51, √P_b=54.77)
     ≈ 2000
   ```

2. 计算新价格下的资产：

   ```
   √P₁ = √2500 = 50
   
   x₁ = L * (√P_b - √P₁) / (√P₁ * √P_b)
      = 2000 * (54.77 - 50) / (50 * 54.77)
      ≈ 0.85 ETH
   
   y₁ = L * (√P₁ - √P_a)
      = 2000 * (50 - 36.51)
      ≈ 6572.9 USDC
   ```

3. 验证（使用增量方法）：

   ```
   Δx = L * (1/50 - 1/44.72) = 2000 * (-0.00236) ≈ -1.15
   Δy = L * (50 - 44.72) = 2000 * 5.28 ≈ 2572.9
   
   x₁ = 2 + (-1.15) = 0.85 ETH ✓
   y₁ = 4000 + 2572.9 = 6572.9 USDC ✓
   ```

---

## 关键要点总结

### 1. 为什么这些公式重要？

- **资本效率**：集中流动性使相同资本产生更多手续费
- **风险管理**：精确计算价格范围和资产分布
- **收益优化**：根据市场预期调整流动性位置

### 2. 公式之间的关系

```
流动性L ←→ 代币数量(x, y) ←→ 价格边界(P_a, P_b)
     ↑                              ↑
     └──────── 当前价格P ───────────┘
```

- 知道其中任意3个变量，可以计算第4个
- 不同公式提供了不同的计算路径

### 3. 实践建议

1. **选择价格范围**：
   - 太窄：资本效率高但容易越界
   - 太宽：资本效率低但更安全
   - 建议：根据历史波动率选择

2. **监控头寸**：
   - 定期检查价格是否在范围内
   - 计算当前资产分布
   - 评估无常损失

3. **再平衡策略**：
   - 价格接近边界时考虑调整
   - 累积手续费达到一定量时收获
   - 根据市场变化重新设置范围

### 4. 常见误区

1. **误区1**：流动性L就是资产总价值
   - **正确**：L是一个抽象的数学量，不直接等于资产价值

2. **误区2**：价格范围越窄越好
   - **正确**：需要平衡资本效率和风险

3. **误区3**：可以无限制地提供流动性
   - **正确**：受到代币数量和价格范围的约束

---

## 数学符号对照表

| 符号 | 含义 | Python变量名 |
|------|------|-------------|
| P | 价格（token1/token0） | `p` |
| √P | 价格的平方根 | `sp` |
| P_a | 价格下限 | `a` |
| √P_a | 价格下限的平方根 | `sa` |
| P_b | 价格上限 | `b` |
| √P_b | 价格上限的平方根 | `sb` |
| L | 流动性 | `L` 或 `liquidity` |
| x | token0的数量 | `x` 或 `amount0` |
| y | token1的数量 | `y` 或 `amount1` |
| Δx | token0的变化量 | `delta_x` |
| Δy | token1的变化量 | `delta_y` |
| c | 上限价格比率（√P_b/√P） | `c` |
| d | 下限价格比率（√P_a/√P） | `d` |

---

## 延伸阅读

1. **Uniswap v3 白皮书**
   - 详细的数学推导
   - 集中流动性的理论基础

2. **Uniswap v3 Core合约**
   - 实际的Solidity实现
   - Q64.96定点数运算

3. **流动性提供策略**
   - 主动管理 vs 被动持有
   - 多头寸策略
   - 再平衡算法

4. **无常损失分析**
   - 与Uniswap v2的对比
   - 集中流动性下的IL计算
   - 手续费补偿模型

---

## 附录：完整公式列表

### 流动性计算

```
L₀ = x * √P * √P_b / (√P_b - √P)
L₁ = y / (√P_b - √P_a)
L = min(L₀, L₁)  （当价格在范围内）
```

### 代币数量计算

```
x = L * (√P_b - √P) / (√P * √P_b)
y = L * (√P - √P_a)
```

### 价格边界计算

```
P_a = (√P - y/L)²
P_a = [y/(√P_b * x) + √P - y/(√P * x)]²
P_b = (L * √P / (L - √P * x))²
P_b = [(√P * y) / ((√P_a * √P - P) * x + y)]²
```

### 增量计算

```
Δx = L * (1/√P₁ - 1/√P₀)
Δy = L * (√P₁ - √P₀)
```

### 价格转换

```
P = 1.0001^tick
tick = log₁.₀₀₀₁(P)
```

---

**版本**: 1.0  
**最后更新**: 2026-02-06  
**作者**: 基于Uniswap v3技术文档整理
