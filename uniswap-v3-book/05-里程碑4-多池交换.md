# 里程碑 4：Multi-pool Swap（多池交换）

> 来源：[uniswapv3book.com/milestone_4](https://uniswapv3book.com/milestone_4/introduction.html)  
> 完整源码：[milestone_4 分支](https://github.com/Jeiwan/uniswapv3-code/tree/milestone_4)  
> 与上一里程碑的变更：[查看 diff](https://github.com/Jeiwan/uniswapv3-code/compare/milestone_3...milestone_4)

---

## 介绍

上一个里程碑实现了跨 tick 交换，但还有一个重大限制：只能在单个池内交换。如果两个代币之间没有池，就无法直接交换。

**解决方案：多池交换**——通过中间代币路由，例如：
```
WBTC → WETH → USDC → USDT → WBTC
```

这个里程碑的计划：

1. **Factory 合约**：管理池的部署和查找
2. **Path 库**：编码多池交换路径
3. **多池交换**：在 Manager 合约中实现链式交换
4. **Tick Spacing**：优化交换效率的设置
5. **Tick Rounding**：处理 tick 间距

---

## 工厂合约

### 设计目标

Factory 合约有三个主要目的：

1. **预测池地址**：无需查询注册表即可计算池地址
2. **简化池部署**：从智能合约部署新池
3. **中央注册表**：维护所有已部署池的记录

### CREATE 与 CREATE2

EVM 有两种部署合约的方式：

- **CREATE**：使用部署者的 `nonce` 生成地址（不确定性）
- **CREATE2**：使用自定义 salt 生成地址（**确定性**）

```
CREATE2 地址 = keccak256(0xff + 部署者地址 + salt + 合约代码哈希)
```

Uniswap Factory 使用 `CREATE2`，以便可以预测性地计算池地址。

### Tick Spacing（Tick 间距）

`tickSpacing` 设置控制已初始化 tick 之间的距离：
- **间距越小**：精度越高，但 swap 循环迭代次数越多，Gas 越贵
- **间距越大**：Gas 效率更高，但精度较低

| Tick Spacing | 适用场景 |
|---|---|
| 10 | 低波动性（稳定币对，如 USDC/USDT）|
| 60 | 中高波动性（ETH/USDC 等）|

**重要**：只有是 `tickSpacing` 倍数的 tick 才能被初始化。例如 tickSpacing=60，只有 -120, -60, 0, 60, 120 等才能被使用。

每个池由以下参数唯一标识：
- `token0` 地址
- `token1` 地址
- `tickSpacing`

### Factory 实现

```solidity
// src/UniswapV3Factory.sol
contract UniswapV3Factory is IUniswapV3PoolDeployer {
    PoolParameters public parameters;
    mapping(uint24 => bool) public tickSpacings;
    mapping(address => mapping(address => mapping(uint24 => address))) public pools;

    constructor() {
        tickSpacings[10] = true;
        tickSpacings[60] = true;
    }

    function createPool(
        address tokenX,
        address tokenY,
        uint24 tickSpacing
    ) public returns (address pool) {
        if (tokenX == tokenY) revert TokensMustBeDifferent();
        if (!tickSpacings[tickSpacing]) revert UnsupportedTickSpacing();

        // 确保 token0 < token1（地址排序）
        (tokenX, tokenY) = tokenX < tokenY
            ? (tokenX, tokenY)
            : (tokenY, tokenX);

        if (tokenX == address(0)) revert TokenXCannotBeZero();
        if (pools[tokenX][tokenY][tickSpacing] != address(0))
            revert PoolAlreadyExists();

        // 使用 IoC 模式传递参数
        parameters = PoolParameters({
            factory: address(this),
            token0: tokenX,
            token1: tokenY,
            tickSpacing: tickSpacing
        });

        // 使用 CREATE2 部署（salt 包含唯一标识参数）
        pool = address(
            new UniswapV3Pool{
                salt: keccak256(abi.encodePacked(tokenX, tokenY, tickSpacing))
            }()
        );

        delete parameters;  // 清理临时状态变量以节省 Gas

        pools[tokenX][tokenY][tickSpacing] = pool;
        pools[tokenY][tokenX][tickSpacing] = pool;

        emit PoolCreated(tokenX, tokenY, tickSpacing, pool);
    }
}
```

### 控制反转（IoC）部署模式

Pool 合约在构造函数中向 Factory 查询参数：

```solidity
// src/UniswapV3Pool.sol
constructor() {
    (factory, token0, token1, tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();
}
```

**流程：**
```
Factory 设置 parameters → 部署 Pool → Pool 在构造函数中读取 parameters → Factory 清除 parameters
```

### 池初始化

池不再在构造函数中设置价格，而是通过单独的 `initialize` 函数：

```solidity
// src/UniswapV3Pool.sol
function initialize(uint160 sqrtPriceX96) public {
    if (slot0.sqrtPriceX96 != 0) revert AlreadyInitialized();
    int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
    slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick});
}
```

使用方式：

```solidity
UniswapV3Factory factory = new UniswapV3Factory();
UniswapV3Pool pool = UniswapV3Pool(factory.createPool(token0, token1, tickSpacing));
pool.initialize(sqrtP(currentPrice));
```

### PoolAddress 库

用于从其他合约计算池地址，无需外部调用：

```solidity
library PoolAddress {
    function computeAddress(
        address factory,
        address token0,
        address token1,
        uint24 tickSpacing
    ) internal pure returns (address pool) {
        require(token0 < token1);

        pool = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex"ff",                                    // CREATE2 标识
                            factory,                                   // 部署者
                            keccak256(abi.encodePacked(token0, token1, tickSpacing)),  // salt
                            keccak256(type(UniswapV3Pool).creationCode)  // 合约代码哈希
                        )
                    )
                )
            )
        );
    }
}
```

这实现了 [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) 定义的合约地址生成规则。

---

## 兑换路径

### Path 编码

多池交换通过编码的**路径**（path）来定义：

```
tokenA → fee/tickSpacing → tokenB → fee/tickSpacing → tokenC
```

路径是一个字节序列，包含交替的代币地址和池参数。

### Path 库

```solidity
library Path {
    uint256 private constant ADDR_SIZE = 20;   // 地址大小（字节）
    uint256 private constant TICKSPACING_SIZE = 3;  // tickSpacing 大小（字节）
    uint256 private constant NEXT_OFFSET = ADDR_SIZE + TICKSPACING_SIZE;  // 23
    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;       // 43
    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;  // 66

    // 路径是否包含多个池
    function hasMultiplePools(bytes memory path) internal pure returns (bool) {
        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;
    }

    // 从路径中获取第一个池的参数
    function getFirstPool(bytes memory path)
        internal pure returns (bytes memory)
    {
        return path.slice(0, POP_OFFSET);
    }

    // 跳过第一个 token 和 tickSpacing（移到下一个池）
    function skipToken(bytes memory path)
        internal pure returns (bytes memory)
    {
        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);
    }

    // 解码第一个池的参数
    function decodeFirstPool(bytes memory path)
        internal pure returns (
            address tokenIn,
            address tokenOut,
            uint24 tickSpacing
        )
    {
        tokenIn = path.toAddress(0);
        tickSpacing = path.toUint24(ADDR_SIZE);
        tokenOut = path.toAddress(NEXT_OFFSET);
    }
}
```

---

## 多池交易

### Manager 合约中的多池交换

```solidity
struct SwapParams {
    bytes path;           // 编码的交换路径
    address recipient;
    uint256 amountIn;
    uint256 minAmountOut;
}

function swap(SwapParams memory params) public returns (uint256 amountOut) {
    address payer = msg.sender;

    while (true) {
        bool hasMultiplePools = params.path.hasMultiplePools();

        // 在当前池中交换
        params.amountIn = _swap(
            params.amountIn,
            hasMultiplePools ? address(this) : params.recipient,  // 中间步骤接收者是自身
            0,
            SwapCallbackData({
                path: params.path.getFirstPool(),
                payer: payer
            })
        );

        if (hasMultiplePools) {
            // 继续下一个池
            payer = address(this);  // 之后由合约自身支付
            params.path = params.path.skipToken();
        } else {
            amountOut = params.amountIn;
            break;
        }
    }

    if (amountOut < params.minAmountOut)
        revert TooLittleReceived(amountOut);
}
```

### 推断 zeroForOne

有了 PoolAddress 库后，可以通过比较代币地址自动推断交换方向：

```solidity
// zeroForOne = true 当 tokenIn < tokenOut（地址比较）
bool zeroForOne = tokenIn < tokenOut;
```

因为 `token0` 始终是地址较小的代币，所以：
- 如果 `tokenIn < tokenOut`，则卖出 token0（`zeroForOne = true`）
- 否则，卖出 token1（`zeroForOne = false`）

---

## Tick Rounding

### 问题

当用户指定的 tick 不是 `tickSpacing` 的倍数时，需要**向最近的有效 tick 取整**。

### 实现

```solidity
function nearestUsableTick(int24 tick_, uint24 tickSpacing)
    internal pure returns (int24 result)
{
    result = int24(divRound(int128(tick_), int128(int24(tickSpacing)))) *
        int24(tickSpacing);

    if (result < TickMath.MIN_TICK) {
        result += int24(tickSpacing);
    } else if (result > TickMath.MAX_TICK) {
        result -= int24(tickSpacing);
    }
}
```

其中 `divRound` 是一个四舍五入的整数除法：

```solidity
function divRound(int128 numerator, int128 denominator)
    internal pure returns (int128 result)
{
    int128 _result = numerator / denominator;
    if (numerator % denominator != 0) {
        // 检查符号，决定向上还是向下取整
        if ((numerator ^ denominator) > 0) {
            result = _result + 1;
        } else {
            result = _result - 1;
        }
    }
    // 此处应有取整逻辑...
    return _result;  // 简化版本
}
```

---

## 简化后的接口

有了 Factory 和 PoolAddress 后，用户不再需要提供池地址，只需提供代币地址和 tickSpacing：

```javascript
// 之前：需要提供池地址
manager.mint(poolAddress, lowerTick, upperTick, ...)

// 现在：只需代币信息
manager.mint({
  tokenA: "0xWETH...",
  tokenB: "0xUSDC...",
  tickSpacing: 60,
  lowerTick: ...,
  upperTick: ...,
  ...
})
```

---

*[← 里程碑 3：跨 Tick Swap](./04-里程碑3-跨Tick-Swap.md) | [里程碑 5：费用与价格预言机 →](./06-里程碑5-费用与价格预言机.md)*
