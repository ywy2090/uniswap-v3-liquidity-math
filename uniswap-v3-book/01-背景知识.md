# 背景知识

> 来源：[uniswapv3book.com](https://uniswapv3book.com/)

---

## 市场介绍

### 中心化交易所如何运作

在本书中，我们将构建一个运行在以太坊上的去中心化交易所（DEX）。所有中心化交易所的核心都有一个**订单簿**。订单簿是一个存储交易者想要进行的所有卖单和买单的日志。订单簿中的每个订单包含执行价格和买卖数量。

交易发生必须存在**流动性**，即市场上资产的可用性。在中心化交易所中，订单簿是流动性积累的地方。

当没有流动性但市场仍有交易兴趣时，**做市商**便会介入。做市商是为市场提供流动性的公司或个人，他们有大量资金来购买不同资产并在交易所出售。

### 去中心化交易所如何运作

去中心化交易所也需要流动性，也需要有人为广泛的资产交易者提供流动性。然而，这个过程不能以中心化的方式处理，必须找到去中心化的解决方案。

### 自动做市商（AMM）

链上市场的演变带来了**自动做市商（AMM）**的概念。AMM 算法像做市商一样工作，但是以自动化的方式。此外，它是去中心化和无需许可的：

- 任何人都可以从任何地方使用它
- 所有资产不存储在一个地方
- 不受单一实体的管理

#### 什么是 AMM？

AMM 是一组定义流动性管理方式的智能合约。每个交易对（例如 ETH/USDC）是一个独立的合约，存储 ETH 和 USDC 并被编程来调解交易。

**核心思想是资金池（Pooling）**：每个合约都是一个存储流动性的池，让不同用户（包括其他智能合约）以无需许可的方式进行交易。有两种角色：流动性提供者和交易者。

---

## 恒定函数做市商

> 本章内容参考了 [Uniswap V2 白皮书](https://uniswap.org/whitepaper.pdf)

我们将构建一种特定类型的 AMM——**恒定函数做市商（Constant Function Market Maker, CFMM）**。

其核心是一个非常简单的数学公式：

$$x \cdot y = k$$

其中 $x$ 和 $y$ 是池合约的储备（持有的代币数量），$k$ 是它们的乘积（一个常数）。

**恒定函数公式说明**：每次交易后，$k$ 必须保持不变。当交易者进行交易时，他们向池中投入一定数量的一种代币（他们想卖的代币），并从池中取出一定数量的另一种代币。这改变了池的储备，但乘积必须不变。

### 交易函数

交易过程如下：

1. 有一个池，持有一定量的 token0（$x_0$）和 token1（$y_0$）
2. 当买入 token1 时，给池一些 token0（$\Delta x$）
3. 池扣除一小部分手续费（$\rho$）
4. 池给我们一些 token1（$\Delta y$）
5. 更新后储备的乘积仍等于 $k$

我们可以从交易公式中推导出输出数量：

$$\Delta y = \frac{y_0 \cdot \Delta x}{x_0 + \Delta x}$$

或反向（已知输出求输入）：

$$\Delta x = \frac{x_0 \cdot \Delta y}{y_0 - \Delta y}$$

### 定价

池中代币的价格由供应量决定，即池持有的代币储备量：

$$P_x = \frac{y}{x}, \quad P_y = \frac{x}{y}$$

这些价格称为**现货价格**，只反映当前市场价格。

### 曲线

恒定乘积函数绘制出来是一条**二次双曲线**：

```
y
|         \
|          \
|           \
|            \___
|                 \___________
+----------------------------- x
```

每次交易从曲线上对应当前储备比例的点开始。出售 token0 意味着沿曲线从一点移动到另一点。

**重要性质**：当购买量相对于池储备较大时，价格会更高——这正是供需法则的体现！

---

## Uniswap V3 简介

> 本章内容参考了 [Uniswap V3 白皮书](https://uniswap.org/whitepaper-v3.pdf)

### Uniswap V2 的不足

Uniswap V2 是一个通用交易所，实现了一种 AMM 算法。但交易对并不都相等：

1. **低波动性代币**：主要是稳定币，如 USDC/USDT、USDC/DAI 等
2. **中高价格波动性代币**：大多数代币

V2 的问题在于**流动性分布在无限价格范围内**——从 0 到无穷大，这使得资本效率低下。历史上资产价格总是在某个范围内，在当前价格很远的地方提供流动性没有意义。

### 集中流动性

**Uniswap V3 引入了集中流动性**：流动性提供者现在可以选择他们想要提供流动性的价格范围。这通过将更多流动性放入更窄的价格范围来提高资本效率。

简而言之，**Uniswap V3 池是许多小型 Uniswap V2 池**。主要区别在于 V3 中一个交易对有许多价格范围，每个价格范围有有限的储备。

### Uniswap V3 的数学

#### 流动性 $L$

$$L = \sqrt{x \cdot y}$$

$L$ 是流动性的度量，是 $x$ 和 $y$ 的几何平均数。

#### $\sqrt{P}$（sqrtPrice）

$\sqrt{P}$ 是 token0 以 token1 表示的价格的平方根。Uniswap V3 使用 $\sqrt{P}$ 而非 $P$，因为：

1. 平方根计算不精确，存储 $\sqrt{P}$ 避免了合约中的精确计算
2. $\sqrt{P}$ 与 $L$ 有一个有趣的关系：$\sqrt{P}$ 也是输出数量变化与 $L$ 变化之间的比率

#### 价格计算

基于 $\sqrt{P}$ 和 $L$：

$$\Delta x = \Delta \frac{1}{\sqrt{P}} \cdot L$$
$$\Delta y = \Delta \sqrt{P} \cdot L$$

#### Tick（价格刻度）

V3 将整个价格范围用均匀分布的离散 tick 来划分。每个 tick 有一个索引，对应某个价格：

$$\sqrt{P}(i) = 1.0001^{i/2}$$

相邻两个 tick 之间的差值为 0.01%（1 个基点）。

Tick 是可以为正和负的整数，范围为：

$$i_{min} = -887272, \quad i_{max} = 887272$$

$\sqrt{P}$ 存储为 Q64.96 定点数（64 位整数部分 + 96 位小数部分）。

---

## 开发环境

### 我们将构建的两个应用

1. **链下应用**：与智能合约交互的前端应用
2. **链上应用**：部署在以太坊上的一组智能合约

### 以太坊简介

以太坊的核心是一个数据库。以太坊数据库中最有价值的数据是账户的状态。账户包含：

1. **Nonce**：用于防止重放攻击的序列整数
2. **Storage**：智能合约存储数据的空间
3. **Code**：部署在此地址的智能合约字节码
4. **Balance**：账户的以太币余额

以太坊也是一个网络，由独立维护状态的计算机组成。每个以太坊节点也运行 EVM（以太坊虚拟机），EVM 是执行智能合约的程序。

### 本地开发环境

我们使用 **Foundry** 作为主要的智能合约开发和测试工具：

- [**Forge**](https://github.com/foundry-rs/foundry/tree/master/forge)：测试框架，可在内部 EVM 上运行测试，无需启动节点
- [**Anvil**](https://github.com/foundry-rs/foundry/tree/master/anvil)：本地以太坊节点，用于部署合约
- [**Cast**](https://github.com/foundry-rs/foundry/tree/master/cast)：命令行工具

为什么选择 Foundry？
- 无需在测试时运行节点，测试更快
- 可以用 **Solidity** 编写测试（而非 JavaScript）

### 前端工具

- [**Ethers.js**](https://github.com/ethers-io/ethers.js/)：以太坊 JavaScript 工具库
- [**MetaMask**](https://metamask.io/)：浏览器中的以太坊钱包
- [**React**](https://reactjs.org/)：前端框架

### 项目初始化

```bash
# 创建项目目录
mkdir uniswapv3clone
cd uniswapv3clone

# 初始化 Forge 项目
forge init

# 创建前端应用（可选）
npx create-react-app ui
```

---

## 我们将构建什么

### 智能合约

完成本书后，你将实现以下合约：

1. **`UniswapV3Pool`**（核心池合约）
   - 实现流动性管理和交换
   - 只处理"精确输入"交换（已知输入数量）
   - 与[原始版本](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol)非常接近

2. **`UniswapV3Factory`**（注册表合约）
   - 部署新池并保存所有已部署池的记录
   - 与[原始版本](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Factory.sol)基本相同

3. **`UniswapV3Manager`**（外围合约）
   - 使与核心合约的交互更方便
   - 是 [SwapRouter](https://github.com/Uniswap/v3-periphery/blob/main/contracts/SwapRouter.sol) 的简化实现

4. **`UniswapV3Quoter`**（报价合约）
   - 允许链上计算交换价格
   - 不实际执行交换

5. **`UniswapV3NFTManager`**（NFT 管理合约）
   - 允许将流动性仓位转换为 NFT
   - 是 [NonfungiblePositionManager](https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol) 的简化实现

### 前端应用

一个简化版的 [Uniswap UI](https://app.uniswap.org/) 克隆，演示前端应用如何使用 Ethers.js 和 MetaMask 与智能合约交互。

---

*[← 返回目录](./00-课程概览.md) | [里程碑 1：首次 Swap →](./02-里程碑1-首次Swap.md)*
