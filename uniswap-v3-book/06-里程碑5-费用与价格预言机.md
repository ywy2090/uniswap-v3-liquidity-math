# 里程碑 5：费用与价格预言机

> 来源：[uniswapv3book.com/milestone_5](https://uniswapv3book.com/milestone_5/introduction.html)  
> 完整源码：[milestone_5 分支](https://github.com/Jeiwan/uniswapv3-code/tree/milestone_5)  
> 与上一里程碑的变更：[查看 diff](https://github.com/Jeiwan/uniswapv3-code/compare/milestone_4...milestone_5)

---

## 介绍

在这个里程碑中，我们为 Uniswap V3 实现添加两个重要功能：

1. **交换费用（Swap Fees）**：DEX 设计的关键机制，激励流动性提供者提供流动性
2. **价格预言机（Price Oracle）**：可选的实用工具，DEX 在进行交易的同时也可以提供代币价格

这两个功能都建立在已有实现之上，这也是为何放在最后来介绍。

---

## 兑换费用

### 费用的重要性

**交换费用是 DEX 设计的粘合剂**：

- 激励流动性提供者提供流动性
- 没有流动性，交易就无法进行
- 费用按照流动性比例分配给流动性提供者

### Uniswap V3 中的费用等级

不同的池可以有不同的费用等级：
- **0.05%**（5 bps）：稳定币对（如 USDC/USDT）
- **0.3%**（30 bps）：标准交易对（如 ETH/USDC）
- **1%**（100 bps）：高波动性或低流动性代币

### 费用计算

交换时，费用从**输入代币**中扣除：

$$\text{输入金额（含费）} = \frac{\text{输入金额}}{1 - \text{费率}}$$

或等价地：

$$\text{实际使用于交换的金额} = \text{输入金额} \cdot (1 - \text{费率})$$

### 全局费用追踪

使用**费用增长**（fee growth）变量追踪累积费用，而非每笔交易单独记录：

```solidity
// 每单位流动性的累积费用
uint256 public feeGrowthGlobal0X128;  // token0 的费用
uint256 public feeGrowthGlobal1X128;  // token1 的费用
```

这些值是**单调递增**的，每次交换时更新：

$$\text{feeGrowthGlobal} += \frac{\text{fees} \cdot 2^{128}}{L}$$

使用 $2^{128}$ 是因为费用通常很小，乘以大数可以保持精度（Q128.128 格式）。

### Tick 中的费用追踪

每个 tick 记录它**被激活时的**费用增长：

```solidity
struct Info {
    uint128 liquidityGross;
    int128 liquidityNet;
    uint256 feeGrowthOutside0X128;  // 新增：穿越时在该 tick 外侧累积的 token0 费用
    uint256 feeGrowthOutside1X128;  // 新增：穿越时在该 tick 外侧累积的 token1 费用
}
```

当穿越 tick 时，更新 `feeGrowthOutside`：

```solidity
function cross(
    mapping(int24 => Tick.Info) storage self,
    int24 tick,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
) internal returns (int128 liquidityDelta) {
    Tick.Info storage info = self[tick];
    info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
    info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
    liquidityDelta = info.liquidityNet;
}
```

### 计算特定价格范围内的费用增长

```solidity
function getFeeGrowthInside(
    mapping(int24 => Tick.Info) storage self,
    int24 lowerTick_,
    int24 upperTick_,
    int24 currentTick,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
) internal view returns (
    uint256 feeGrowthInside0X128,
    uint256 feeGrowthInside1X128
) {
    Tick.Info storage lowerTick = self[lowerTick_];
    Tick.Info storage upperTick = self[upperTick_];

    uint256 feeGrowthBelow0X128;
    uint256 feeGrowthBelow1X128;
    if (currentTick >= lowerTick_) {
        feeGrowthBelow0X128 = lowerTick.feeGrowthOutside0X128;
        feeGrowthBelow1X128 = lowerTick.feeGrowthOutside1X128;
    } else {
        feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lowerTick.feeGrowthOutside0X128;
        feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lowerTick.feeGrowthOutside1X128;
    }

    uint256 feeGrowthAbove0X128;
    uint256 feeGrowthAbove1X128;
    if (currentTick < upperTick_) {
        feeGrowthAbove0X128 = upperTick.feeGrowthOutside0X128;
        feeGrowthAbove1X128 = upperTick.feeGrowthOutside1X128;
    } else {
        feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upperTick.feeGrowthOutside0X128;
        feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upperTick.feeGrowthOutside1X128;
    }

    feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
    feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
}
```

### 仓位中的费用追踪

每个仓位记录**上次收取时**的费用增长：

```solidity
struct Info {
    uint128 liquidity;
    uint256 feeGrowthInside0LastX128;  // 上次收取时的费用增长
    uint256 feeGrowthInside1LastX128;
    uint128 tokensOwed0;               // 可以收取的 token0 费用
    uint128 tokensOwed1;               // 可以收取的 token1 费用
}
```

计算应得费用：

$$\text{fees} = L \cdot (\text{feeGrowthInside} - \text{feeGrowthInsideLast})$$

```solidity
function update(
    mapping(bytes32 => Info) storage self,
    address owner,
    int24 lowerTick,
    int24 upperTick,
    int128 liquidityDelta,
    uint256 feeGrowthInside0X128,
    uint256 feeGrowthInside1X128
) internal {
    Info storage info = self.get(owner, lowerTick, upperTick);

    // 计算累积费用
    uint128 tokensOwed0 = uint128(
        FullMath.mulDiv(
            feeGrowthInside0X128 - info.feeGrowthInside0LastX128,
            info.liquidity,
            FixedPoint128.Q128
        )
    );
    uint128 tokensOwed1 = uint128(
        FullMath.mulDiv(
            feeGrowthInside1X128 - info.feeGrowthInside1LastX128,
            info.liquidity,
            FixedPoint128.Q128
        )
    );

    info.liquidity = LiquidityMath.addLiquidity(info.liquidity, liquidityDelta);
    info.feeGrowthInside0LastX128 = feeGrowthInside0X128;
    info.feeGrowthInside1LastX128 = feeGrowthInside1X128;

    if (tokensOwed0 > 0 || tokensOwed1 > 0) {
        info.tokensOwed0 += tokensOwed0;
        info.tokensOwed1 += tokensOwed1;
    }
}
```

### 收取费用

流动性提供者通过 `collect` 函数收取累积费用：

```solidity
function collect(
    address recipient,
    int24 lowerTick,
    int24 upperTick,
    uint128 amount0Requested,
    uint128 amount1Requested
) public returns (uint128 amount0, uint128 amount1) {
    Position.Info storage position = positions.get(
        msg.sender, lowerTick, upperTick
    );

    amount0 = amount0Requested > position.tokensOwed0
        ? position.tokensOwed0
        : amount0Requested;
    amount1 = amount1Requested > position.tokensOwed1
        ? position.tokensOwed1
        : amount1Requested;

    if (amount0 > 0) {
        position.tokensOwed0 -= amount0;
        IERC20(token0).transfer(recipient, amount0);
    }
    if (amount1 > 0) {
        position.tokensOwed1 -= amount1;
        IERC20(token1).transfer(recipient, amount1);
    }

    emit Collect(msg.sender, recipient, lowerTick, upperTick, amount0, amount1);
}
```

---

## 闪电贷费用

闪电贷也收取少量费用（如 0.09%）：

```solidity
function flash(
    uint256 amount0,
    uint256 amount1,
    bytes calldata data
) public {
    uint256 fee0 = Math.mulDivRoundingUp(amount0, fee, 1e6);
    uint256 fee1 = Math.mulDivRoundingUp(amount1, fee, 1e6);

    uint256 balance0Before = IERC20(token0).balanceOf(address(this));
    uint256 balance1Before = IERC20(token1).balanceOf(address(this));

    if (amount0 > 0) IERC20(token0).transfer(msg.sender, amount0);
    if (amount1 > 0) IERC20(token1).transfer(msg.sender, amount1);

    IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);

    // 验证还款（含费用）
    if (IERC20(token0).balanceOf(address(this)) < balance0Before + fee0)
        revert FlashLoanNotPaid();
    if (IERC20(token1).balanceOf(address(this)) < balance1Before + fee1)
        revert FlashLoanNotPaid();

    emit Flash(msg.sender, amount0, amount1);
}
```

---

## 协议费用

除了流动性提供者费用，Uniswap 还有**协议费用**（Protocol Fee）。协议费用是从交换费用中扣除的一部分，归 Uniswap 协议治理控制的地址所有。

在 Pool 合约中：

```solidity
// 协议费用累积（以整数形式，相比 feeGrowth 精度更低）
uint128 public protocolFeesAccumulated0;
uint128 public protocolFeesAccumulated1;

// 协议费用收取函数（只有授权地址可以调用）
function collectProtocol(
    address recipient,
    uint128 amount0Requested,
    uint128 amount1Requested
) public returns (uint128 amount0, uint128 amount1) {
    ...
}
```

---

## 价格预言机

### 什么是价格预言机？

**价格预言机**是为链上其他应用提供资产价格的机制。Uniswap V3 内置了一个基于**时间加权平均价格（TWAP）**的价格预言机。

### 时间加权平均价格（TWAP）

TWAP 对价格操纵有很强的抵抗力：

$$\text{TWAP} = \frac{\sum(\text{价格} \times \text{时间})}{\text{总时间}}$$

Uniswap V3 存储的是**tick 的累积值**（而非价格），因为 tick 更易于数学操作：

$$\text{tickCumulative}_t = \text{tickCumulative}_{t-1} + \text{tick}_{t-1} \times (t - t_{t-1})$$

### 预言机数据存储

使用**循环缓冲区**（Circular Buffer）存储历史观测值：

```solidity
struct Observation {
    uint32 timestamp;         // 观测时间戳
    int56 tickCumulative;     // 累积 tick（tick * 经过的秒数之和）
    bool initialized;         // 是否已初始化
}

// 在 Pool 合约中
Observation[65535] public observations;
```

### 记录观测值

在每次交换时，写入新的观测值：

```solidity
function _updateSlot0AndObservation(
    int24 tick,
    uint160 sqrtPriceX96,
    uint16 observationIndex,
    uint16 observationCardinality
) internal {
    Slot0 memory _slot0 = slot0;

    uint16 updatedIndex = observations.write(
        observationIndex,
        _blockTimestamp(),
        _slot0.tick,
        observationCardinality
    );

    slot0 = Slot0({
        sqrtPriceX96: sqrtPriceX96,
        tick: tick,
        observationIndex: updatedIndex,
        observationCardinality: observationCardinality
    });
}
```

### 增加观测容量

由于存储昂贵，默认只存储 1 个观测值（每个区块覆盖上一个）。用户可以调用 `increaseObservationCardinalityNext` 增加容量：

```solidity
function increaseObservationCardinalityNext(uint16 observationCardinalityNext) public {
    uint16 observationCardinalityNextOld = slot0.observationCardinalityNext;
    uint16 observationCardinalityNextNew = observations.grow(
        observationCardinalityNextOld,
        observationCardinalityNext
    );
    slot0.observationCardinalityNext = observationCardinalityNextNew;
    if (observationCardinalityNextOld != observationCardinalityNextNew)
        emit IncreaseObservationCardinalityNext(
            observationCardinalityNextOld,
            observationCardinalityNextNew
        );
}
```

### 查询 TWAP

```solidity
function observe(uint32[] calldata secondsAgos)
    public view
    returns (int56[] memory tickCumulatives)
{
    return observations.observe(
        _blockTimestamp(),
        secondsAgos,
        slot0.tick,
        slot0.observationIndex,
        slot0.observationCardinality
    );
}
```

使用示例：

```solidity
// 查询最近 60 秒和 0 秒的累积 tick
uint32[] memory secondsAgos = new uint32[](2);
secondsAgos[0] = 60;
secondsAgos[1] = 0;

int56[] memory tickCumulatives = pool.observe(secondsAgos);

// 计算过去 60 秒的平均 tick
int56 averageTick = (tickCumulatives[1] - tickCumulatives[0]) / 60;
```

### TWAP 的抗操纵性

TWAP 难以操纵，因为：
1. 攻击者需要在整个时间窗口内持续操纵价格
2. 这在经济上代价极高
3. 窗口越长，抗操纵性越强

---

*[← 里程碑 4：多池交换](./05-里程碑4-多池交换.md) | [里程碑 6：NFT 仓位 →](./07-里程碑6-NFT仓位.md)*
