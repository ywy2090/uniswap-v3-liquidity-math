# 里程碑 6：NFT 仓位

> 来源：[uniswapv3book.com/milestone_6](https://uniswapv3book.com/milestone_6/introduction.html)  
> 完整源码：[milestone_6 分支](https://github.com/Jeiwan/uniswapv3-code/tree/milestone_6)  
> 与上一里程碑的变更：[查看 diff](https://github.com/Jeiwan/uniswapv3-code/compare/milestone_5...milestone_6)

---

## 介绍

这是本书的最后一个里程碑——**将流动性仓位转换为 NFT 代币**。

这是 Uniswap V3 的一个额外功能，展示了核心合约如何被第三方协议扩展和集成——无需修改核心合约本身。

一个 Uniswap V3 NFT 示例展示了：
- 代币符号
- 池费率
- 仓位 ID
- 上下界 tick
- 代币地址
- 曲线的哪个区段

你可以在 [OpenSea 上查看所有 Uniswap V3 NFT 仓位](https://opensea.io/collection/uniswap-v3-positions)。

---

## ERC721 概述

### 什么是 ERC721？

[EIP-721](https://eips.ethereum.org/EIPS/eip-721) 是定义 NFT 合约的标准。

**ERC721 与 ERC20 的主要区别：**
- ERC20 代币是**可互换的**（同质化）：每个代币与其他代币相同
- ERC721 代币是**不可互换的**（非同质化）：每个代币有唯一 ID

ERC721 代币特性：
1. 每个代币有唯一 ID（通常是铸造时的计数器）
2. 合约追踪每个代币的所有者
3. 只有特定 ID 的代币可以转移（或被授权转移）

这与流动性仓位的共同点是**不可互换性**：NFT 和流动性仓位都不可互换，都通过唯一 ID 标识。

### tokenURI 函数

ERC721 最重要的特征是 `tokenURI` 函数，它将代币 ID 链接到存储在链外的资产：

```json
{
  "name": "Thor's hammer",
  "description": "Mjölnir, the legendary hammer of the Norse god of thunder.",
  "image": "https://game.example/item-id-8u5h2m.png",
  "strength": 20
}
```

**链上存储**：也可以直接在链上存储 JSON 元数据和 SVG 图像，使用 [data URI scheme](https://en.wikipedia.org/wiki/Data_URI_scheme#Syntax) 编码：

```
data:application/json;base64,BASE64_ENCODED_JSON
```

虽然链上存储非常昂贵，但可以通过模板来降低成本——所有代币共享相似的元数据和视觉结构，只有少数字段不同。

---

## NFT Manager 合约

### 设计思路

我们不在 Pool 合约中添加 NFT 功能，而是创建一个独立合约，合并 NFT 和流动性仓位：

- 实现 ERC721 标准
- 管理流动性仓位
- **NFT Manager 合约是流动性的实际所有者**（在池中）
- 每个流动性仓位都链接到一个 NFT，保持同步

### 最小化合约框架

```solidity
// 使用 Solmate 的 ERC721 实现（比 OpenZeppelin 更节省 Gas）
contract UniswapV3NFTManager is ERC721 {
    address public immutable factory;

    constructor(address factoryAddress)
        ERC721("UniswapV3 NFT Positions", "UNIV3")
    {
        factory = factoryAddress;
    }

    function tokenURI(uint256 tokenId)
        public view override returns (string memory)
    {
        return "";  // 先返回空字符串，后续实现渲染器
    }
}
```

### 数据结构

```solidity
struct TokenPosition {
    address pool;    // 池地址
    int24 lowerTick; // 下界 tick
    int24 upperTick; // 上界 tick
}

mapping(uint256 => TokenPosition) public positions;  // tokenId => 仓位数据

uint256 public totalSupply;
uint256 private nextTokenId;
```

因为 NFT Manager 合约是所有仓位的所有者，不需要单独存储每个仓位的所有者地址。

### Mint（铸造）

铸造时同时向池添加流动性并铸造 NFT：

```solidity
struct MintParams {
    address recipient;    // NFT 接收者
    address tokenA;
    address tokenB;
    uint24 fee;
    int24 lowerTick;
    int24 upperTick;
    uint256 amount0Desired;
    uint256 amount1Desired;
    uint256 amount0Min;    // 滑点保护
    uint256 amount1Min;
}

function mint(MintParams calldata params) public returns (uint256 tokenId) {
    IUniswapV3Pool pool = getPool(params.tokenA, params.tokenB, params.fee);

    // 1. 向池添加流动性
    (uint128 liquidity, uint256 amount0, uint256 amount1) = _addLiquidity(
        AddLiquidityInternalParams({
            pool: pool,
            lowerTick: params.lowerTick,
            upperTick: params.upperTick,
            amount0Desired: params.amount0Desired,
            amount1Desired: params.amount1Desired,
            amount0Min: params.amount0Min,
            amount1Min: params.amount1Min
        })
    );

    // 2. 铸造 NFT
    tokenId = nextTokenId++;
    _mint(params.recipient, tokenId);
    totalSupply++;

    // 3. 存储仓位信息
    positions[tokenId] = TokenPosition({
        pool: address(pool),
        lowerTick: params.lowerTick,
        upperTick: params.upperTick
    });
}
```

### 增加流动性

向已存在的仓位添加更多流动性（不铸造新 NFT）：

```solidity
function addLiquidity(AddLiquidityParams calldata params)
    public
    returns (uint128 liquidity, uint256 amount0, uint256 amount1)
{
    TokenPosition memory tokenPosition = positions[params.tokenId];
    if (tokenPosition.pool == address(0x00)) revert WrongToken();

    (liquidity, amount0, amount1) = _addLiquidity(
        AddLiquidityInternalParams({
            pool: IUniswapV3Pool(tokenPosition.pool),
            lowerTick: tokenPosition.lowerTick,
            upperTick: tokenPosition.upperTick,
            amount0Desired: params.amount0Desired,
            amount1Desired: params.amount1Desired,
            amount0Min: params.amount0Min,
            amount1Min: params.amount1Min
        })
    );
}
```

### 移除流动性

```solidity
function removeLiquidity(RemoveLiquidityParams memory params)
    public
    isApprovedOrOwner(params.tokenId)  // 权限检查
    returns (uint256 amount0, uint256 amount1)
{
    TokenPosition memory tokenPosition = positions[params.tokenId];
    if (tokenPosition.pool == address(0x00)) revert WrongToken();

    IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool);

    // 检查可用流动性
    (uint128 availableLiquidity, , , , ) = pool.positions(
        poolPositionKey(tokenPosition)
    );
    if (params.liquidity > availableLiquidity) revert NotEnoughLiquidity();

    (amount0, amount1) = pool.burn(
        tokenPosition.lowerTick,
        tokenPosition.upperTick,
        params.liquidity
    );
}
```

### 收取代币

```solidity
function collect(CollectParams memory params)
    public
    isApprovedOrOwner(params.tokenId)
    returns (uint128 amount0, uint128 amount1)
{
    TokenPosition memory tokenPosition = positions[params.tokenId];
    if (tokenPosition.pool == address(0x00)) revert WrongToken();

    IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool);

    // 收取代币，发送给调用者
    (amount0, amount1) = pool.collect(
        msg.sender,
        tokenPosition.lowerTick,
        tokenPosition.upperTick,
        params.amount0,
        params.amount1
    );
}
```

### 销毁 NFT

销毁 NFT **之前必须先**：
1. 移除所有流动性（`removeLiquidity`）
2. 收取所有代币（`collect`）

```solidity
function burn(uint256 tokenId) public isApprovedOrOwner(tokenId) {
    TokenPosition memory tokenPosition = positions[tokenId];
    if (tokenPosition.pool == address(0x00)) revert WrongToken();

    IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool);
    (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = pool
        .positions(poolPositionKey(tokenPosition));

    // 确保仓位已清空
    if (liquidity > 0 || tokensOwed0 > 0 || tokensOwed1 > 0)
        revert PositionNotCleared();

    delete positions[tokenId];
    _burn(tokenId);
    totalSupply--;
}
```

---

## NFT 渲染器

### SVG 模板

我们在链上生成 SVG 图像。每个 NFT 包含：
- 背景颜色（基于所有者地址、tick 计算的唯一色调）
- 代币符号（如 WETH/USDC）
- 池费率（如 0.05%）
- 下界和上界 tick

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 480">
  <style>
    .tokens { font: bold 30px sans-serif; }
    .fee { font: normal 26px sans-serif; }
    .tick { font: normal 18px sans-serif; }
  </style>

  <!-- 背景（颜色基于 keccak256 哈希生成） -->
  <rect width="300" height="480" fill="hsl(330,40%,40%)" />
  <rect x="30" y="30" width="240" height="420" rx="15" ry="15"
        fill="hsl(330,90%,50%)" stroke="#000" />

  <!-- 代币符号 -->
  <rect x="30" y="87" width="240" height="42" />
  <text x="39" y="120" class="tokens" fill="#fff">WETH/USDC</text>

  <!-- 费率 -->
  <rect x="30" y="132" width="240" height="30" />
  <text x="39" y="120" dy="36" class="fee" fill="#fff">0.05%</text>

  <!-- Tick 范围 -->
  <rect x="30" y="342" width="240" height="24" />
  <text x="39" y="360" class="tick" fill="#fff">Lower tick: 84222</text>

  <rect x="30" y="372" width="240" height="24" />
  <text x="39" y="360" dy="30" class="tick" fill="#fff">Upper tick: 86129</text>
</svg>
```

### 渲染器库实现

```solidity
library NFTRenderer {
    struct RenderParams {
        address pool;
        address owner;
        int24 lowerTick;
        int24 upperTick;
        uint24 fee;
    }

    function render(RenderParams memory params)
        internal pure returns (string memory)
    {
        IUniswapV3Pool pool = IUniswapV3Pool(params.pool);
        string memory symbol0 = IERC20(pool.token0()).symbol();
        string memory symbol1 = IERC20(pool.token1()).symbol();

        string memory image = string.concat(
            "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 480'>",
            "<style>.tokens { font: bold 30px sans-serif; }",
            ".fee { font: normal 26px sans-serif; }",
            ".tick { font: normal 18px sans-serif; }</style>",
            renderBackground(params.owner, params.lowerTick, params.upperTick),
            renderTop(symbol0, symbol1, params.fee),
            renderBottom(params.lowerTick, params.upperTick),
            "</svg>"
        );

        string memory description = renderDescription(
            symbol0, symbol1, params.fee,
            params.lowerTick, params.upperTick
        );

        string memory json = string.concat(
            '{"name":"Uniswap V3 Position",',
            '"description":"', description, '",',
            '"image":"data:image/svg+xml;base64,',
            Base64.encode(bytes(image)),
            '"}'
        );

        return string.concat(
            "data:application/json;base64,",
            Base64.encode(bytes(json))
        );
    }
}
```

### 背景渲染（唯一颜色）

```solidity
function renderBackground(
    address owner,
    int24 lowerTick,
    int24 upperTick
) internal pure returns (string memory background) {
    // 基于所有者和 tick 生成唯一色调（0-359）
    bytes32 key = keccak256(abi.encodePacked(owner, lowerTick, upperTick));
    uint256 hue = uint256(key) % 360;

    background = string.concat(
        '<rect width="300" height="480" fill="hsl(',
        Strings.toString(hue), ',40%,40%)"/>',
        '<rect x="30" y="30" width="240" height="420" rx="15" ry="15" fill="hsl(',
        Strings.toString(hue), ',100%,50%)" stroke="#000"/>'
    );
}
```

### Tick 文本渲染（处理负数）

```solidity
function tickToText(int24 tick)
    internal pure returns (string memory tickString)
{
    tickString = string.concat(
        tick < 0 ? "-" : "",
        tick < 0
            ? Strings.toString(uint256(uint24(-tick)))
            : Strings.toString(uint256(uint24(tick)))
    );
}
```

### 在 tokenURI 中调用渲染器

```solidity
function tokenURI(uint256 tokenId)
    public view override returns (string memory)
{
    TokenPosition memory tokenPosition = positions[tokenId];
    if (tokenPosition.pool == address(0x00)) revert WrongToken();

    IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool);

    return NFTRenderer.render(
        NFTRenderer.RenderParams({
            pool: tokenPosition.pool,
            owner: address(this),
            lowerTick: tokenPosition.lowerTick,
            upperTick: tokenPosition.upperTick,
            fee: pool.fee()
        })
    );
}
```

### 依赖库

- **[Base64（OpenZeppelin）](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Base64.sol)**：Base64 编码
- **[Strings（OpenZeppelin）](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol)**：整数转字符串
- **[Solmate ERC721](https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)**：Gas 优化的 ERC721 实现

---

## Gas 成本注意事项

链上存储数据有一个巨大的缺点：**合约部署变得非常昂贵**。

部署合约时，需要为合约大小付费，而所有字符串和模板都会大幅增加 Gas 消耗。

- 本示例中的渲染器**未进行 Gas 优化**，牺牲了效率以提高可读性
- 在实际 NFT 项目中，链上存储通常需要大量优化，代码可读性较差

---

## 测试 NFT 图像

为了确保 NFT 图像在代码变更后不会意外改变，可以使用快照测试：

```solidity
function testTokenURI() public {
    uint256 tokenId = mintPosition();
    
    // 与存储的期望值进行比较
    assertTokenURI(
        nft.tokenURI(tokenId),
        "tokenuri0",
        "invalid token URI"
    );
}

function assertTokenURI(
    string memory actual,
    string memory expectedFixture,
    string memory errMessage
) internal {
    // 使用 Forge 的 vm.readFile 读取期望值
    string memory expected = vm.readFile(
        string.concat("./test/fixtures/", expectedFixture)
    );
    assertEq(actual, string(expected), errMessage);
}
```

在 `foundry.toml` 中配置文件系统权限：

```toml
fs_permissions = [{access='read',path='.'}]
```

从 fixture 文件中提取并查看 SVG：

```bash
cat test/fixtures/tokenuri0 \
    | awk -F ',' '{print $2}' \
    | base64 -d - \
    | jq -r .image \
    | awk -F ',' '{print $2}' \
    | base64 -d - > nft.svg \
    && open nft.svg
```

---

## 总结

恭喜！你已经完成了整本书的所有里程碑！

我们构建了一个功能完整的 Uniswap V3 克隆，包括：

✅ **里程碑 1**：首次 Swap（池合约、流动性管理、基础交换）  
✅ **里程碑 2**：第二次 Swap（双向交换、Tick Bitmap、Quoter）  
✅ **里程碑 3**：跨 Tick Swap（跨价格范围交换、滑点保护、闪电贷）  
✅ **里程碑 4**：多池交换（Factory 合约、路径库、多跳交换）  
✅ **里程碑 5**：费用与价格预言机（交换费用、TWAP 预言机）  
✅ **里程碑 6**：NFT 仓位（ERC721、链上 SVG 渲染）

---

*[← 里程碑 5：费用与价格预言机](./06-里程碑5-费用与价格预言机.md) | [返回目录](./00-课程概览.md)*
